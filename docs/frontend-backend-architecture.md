# å‰åç«¯æ¶æ„è®¾è®¡

## ğŸ—ï¸ æ•´ä½“æ¶æ„

\`\`\`
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    LifeAgent å…¨æ ˆæ¶æ„                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ğŸ¨ Frontend (Next.js 14)                                  â”‚
â”‚  â”œâ”€â”€ App Router Pages                                      â”‚
â”‚  â”œâ”€â”€ React Components                                      â”‚
â”‚  â”œâ”€â”€ ChatAgent UI                                         â”‚
â”‚  â”œâ”€â”€ Real-time State Management (Zustand)                 â”‚
â”‚  â””â”€â”€ Tool Visualization                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ğŸ”— API Layer (Next.js API Routes)                         â”‚
â”‚  â”œâ”€â”€ /api/chat/completion (ChatAgent ç«¯ç‚¹)                 â”‚
â”‚  â”œâ”€â”€ /api/tools/execute (å·¥å…·æ‰§è¡Œç«¯ç‚¹)                      â”‚
â”‚  â”œâ”€â”€ /api/projects/* (é¡¹ç›® CRUD)                           â”‚
â”‚  â”œâ”€â”€ /api/goals/* (ç›®æ ‡ CRUD)                              â”‚
â”‚  â””â”€â”€ /api/reviews/* (åæ€ CRUD)                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ğŸ¤– Agent Processing Layer                                 â”‚
â”‚  â”œâ”€â”€ ChatAgent Core                                       â”‚
â”‚  â”œâ”€â”€ Tool Registry                                        â”‚
â”‚  â”œâ”€â”€ Intent Parser                                        â”‚
â”‚  â””â”€â”€ Context Manager                                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ğŸ’¾ Data Layer                                            â”‚
â”‚  â”œâ”€â”€ PostgreSQL (ç”Ÿäº§ç¯å¢ƒ)                                 â”‚
â”‚  â”œâ”€â”€ Prisma ORM                                           â”‚
â”‚  â”œâ”€â”€ Local Storage (å¼€å‘ç¯å¢ƒ)                              â”‚
â”‚  â””â”€â”€ Data Validation & Migration                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ğŸ”Œ External Integrations                                 â”‚
â”‚  â”œâ”€â”€ OpenAI API (LLM å¢å¼º)                                â”‚
â”‚  â”œâ”€â”€ Vercel AI SDK                                        â”‚
â”‚  â””â”€â”€ Future: Vector Database for RAG                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
\`\`\`

## ğŸ¨ Frontend æ¶æ„

### ç»„ä»¶å±‚æ¬¡ç»“æ„

\`\`\`typescript
// é¡µé¢çº§ç»„ä»¶
app/
â”œâ”€â”€ layout.tsx                    # å…¨å±€å¸ƒå±€
â”œâ”€â”€ page.tsx                     # ä»ªè¡¨ç›˜é¦–é¡µ
â”œâ”€â”€ projects/
â”‚   â”œâ”€â”€ page.tsx                 # é¡¹ç›®åˆ—è¡¨
â”‚   â””â”€â”€ [id]/page.tsx           # é¡¹ç›®è¯¦æƒ…
â”œâ”€â”€ goals/page.tsx               # ç›®æ ‡ç®¡ç†
â””â”€â”€ reviews/page.tsx             # åæ€å›é¡¾

// åŠŸèƒ½ç»„ä»¶
components/
â”œâ”€â”€ chat-agent/
â”‚   â”œâ”€â”€ chat-window.tsx          # ä¸»å¯¹è¯çª—å£
â”‚   â”œâ”€â”€ message-list.tsx         # æ¶ˆæ¯åˆ—è¡¨
â”‚   â”œâ”€â”€ input-area.tsx           # è¾“å…¥åŒºåŸŸ
â”‚   â”œâ”€â”€ tool-call-display.tsx    # å·¥å…·è°ƒç”¨å±•ç¤º
â”‚   â””â”€â”€ context-sidebar.tsx      # ä¸Šä¸‹æ–‡ä¾§è¾¹æ 
â”œâ”€â”€ dashboard/
â”‚   â”œâ”€â”€ overview-cards.tsx       # æ¦‚è§ˆå¡ç‰‡
â”‚   â”œâ”€â”€ recent-activity.tsx      # æœ€è¿‘æ´»åŠ¨
â”‚   â””â”€â”€ quick-actions.tsx        # å¿«é€Ÿæ“ä½œ
â””â”€â”€ shared/
    â”œâ”€â”€ navigation.tsx           # å¯¼èˆªç»„ä»¶
    â”œâ”€â”€ loading-states.tsx       # åŠ è½½çŠ¶æ€
    â””â”€â”€ error-boundaries.tsx     # é”™è¯¯è¾¹ç•Œ
\`\`\`

### çŠ¶æ€ç®¡ç†æ¶æ„

\`\`\`typescript
// Zustand Store åˆ†å±‚è®¾è®¡
interface LifeAgentStore {
  // æ•°æ®çŠ¶æ€
  data: {
    projects: Project[]
    goals: Goal[]
    tasks: Task[]
    reviews: Review[]
  }
  
  // UI çŠ¶æ€
  ui: {
    chatAgent: {
      isOpen: boolean
      isProcessing: boolean
      currentContext: ConversationContext
    }
    navigation: {
      activeTab: string
      sidebarOpen: boolean
    }
  }
  
  // æ“ä½œæ–¹æ³•
  actions: {
    // æ•°æ®æ“ä½œ
    addProject: (project: Omit<Project, 'id'>) => void
    updateProject: (id: string, updates: Partial<Project>) => void
    
    // ChatAgent æ“ä½œ
    sendMessage: (message: string) => Promise<AgentResponse>
    updateChatContext: (context: ConversationContext) => void
    
    // UI æ“ä½œ
    toggleChatAgent: () => void
    setActiveTab: (tab: string) => void
  }
}

// åˆ†ç‰‡çŠ¶æ€ç®¡ç†
const useDataStore = create<DataState>()(
  persist(
    (set, get) => ({
      projects: [],
      goals: [],
      tasks: [],
      reviews: [],
      // ... æ•°æ®æ“ä½œæ–¹æ³•
    }),
    { name: 'lifeagent-data' }
  )
)

const useUIStore = create<UIState>()((set) => ({
  chatAgent: { isOpen: false, isProcessing: false },
  navigation: { activeTab: 'dashboard', sidebarOpen: true },
  // ... UI æ“ä½œæ–¹æ³•
}))

const useChatStore = create<ChatState>()((set, get) => ({
  messages: [],
  currentContext: {},
  // ... èŠå¤©ç›¸å…³æ–¹æ³•
}))
\`\`\`

### å®æ—¶æ›´æ–°æœºåˆ¶

\`\`\`typescript
// ä½¿ç”¨ React 18 çš„å¹¶å‘ç‰¹æ€§
import { useDeferredValue, useTransition } from 'react'

function ChatAgentWindow() {
  const [isPending, startTransition] = useTransition()
  const [message, setMessage] = useState('')
  const deferredMessage = useDeferredValue(message)
  
  const handleSendMessage = async () => {
    startTransition(async () => {
      const response = await chatAgent.processMessage(deferredMessage)
      // æ›´æ–°çŠ¶æ€
    })
  }
  
  return (
    <div className={isPending ? 'opacity-50' : ''}>
      {/* ChatAgent UI */}
    </div>
  )
}

// ä¹è§‚æ›´æ–°ç­–ç•¥
function useOptimisticUpdates() {
  const [optimisticState, setOptimisticState] = useState()
  
  const updateWithOptimism = async (update: any) => {
    // ç«‹å³æ›´æ–° UI
    setOptimisticState(update)
    
    try {
      // å‘é€åˆ°æœåŠ¡å™¨
      await api.update(update)
    } catch (error) {
      // å›æ»šæ›´æ–°
      setOptimisticState(null)
      throw error
    }
  }
  
  return { optimisticState, updateWithOptimism }
}
\`\`\`

## ğŸ”— API Layer è®¾è®¡

### RESTful API ç»“æ„

\`\`\`typescript
// API è·¯ç”±è®¾è®¡
app/api/
â”œâ”€â”€ chat/
â”‚   â””â”€â”€ route.ts                 # POST /api/chat - ChatAgent äº¤äº’
â”œâ”€â”€ tools/
â”‚   â”œâ”€â”€ route.ts                 # POST /api/tools - å·¥å…·æ‰§è¡Œ
â”‚   â””â”€â”€ [toolName]/route.ts      # POST /api/tools/[toolName] - ç‰¹å®šå·¥å…·
â”œâ”€â”€ projects/
â”‚   â”œâ”€â”€ route.ts                 # GET/POST /api/projects
â”‚   â””â”€â”€ [id]/
â”‚       â”œâ”€â”€ route.ts             # GET/PUT/DELETE /api/projects/[id]
â”‚       â”œâ”€â”€ tasks/route.ts       # GET/POST /api/projects/[id]/tasks
â”‚       â””â”€â”€ reviews/route.ts     # GET /api/projects/[id]/reviews
â”œâ”€â”€ goals/
â”‚   â”œâ”€â”€ route.ts                 # GET/POST /api/goals
â”‚   â””â”€â”€ [id]/route.ts           # GET/PUT/DELETE /api/goals/[id]
â”œâ”€â”€ tasks/
â”‚   â”œâ”€â”€ route.ts                 # GET/POST /api/tasks
â”‚   â””â”€â”€ [id]/route.ts           # GET/PUT/DELETE /api/tasks/[id]
â””â”€â”€ reviews/
    â”œâ”€â”€ route.ts                 # GET/POST /api/reviews
    â”œâ”€â”€ [id]/route.ts           # GET/PUT/DELETE /api/reviews/[id]
    â””â”€â”€ analyze/route.ts         # POST /api/reviews/analyze - æ¨¡å¼åˆ†æ
\`\`\`

### ChatAgent API ç«¯ç‚¹

\`\`\`typescript
// app/api/chat/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { ChatAgent } from '@/lib/agents/chat-agent'

const chatAgent = new ChatAgent()

export async function POST(request: NextRequest) {
  try {
    const { message, context } = await request.json()
    
    // å¤„ç†æ¶ˆæ¯
    const response = await chatAgent.processMessage(message, context)
    
    return NextResponse.json({
      success: true,
      data: response
    })
    
  } catch (error) {
    return NextResponse.json({
      success: false,
      error: error.message
    }, { status: 500 })
  }
}

// æµå¼å“åº”æ”¯æŒ
export async function POST(request: NextRequest) {
  const { message } = await request.json()
  
  const stream = new ReadableStream({
    async start(controller) {
      const response = await chatAgent.processMessageStream(message)
      
      for await (const chunk of response) {
        controller.enqueue(new TextEncoder().encode(
          `data: ${JSON.stringify(chunk)}\n\n`
        ))
      }
      
      controller.close()
    }
  })
  
  return new Response(stream, {
    headers: {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive'
    }
  })
}
\`\`\`

### å·¥å…·æ‰§è¡Œ API

\`\`\`typescript
// app/api/tools/route.ts
import { ToolRegistry } from '@/lib/tools/registry'

const toolRegistry = new ToolRegistry()

export async function POST(request: NextRequest) {
  try {
    const { toolName, parameters } = await request.json()
    
    // éªŒè¯å·¥å…·å­˜åœ¨
    const tool = toolRegistry.get(toolName)
    if (!tool) {
      return NextResponse.json({
        success: false,
        error: `Tool ${toolName} not found`
      }, { status: 404 })
    }
    
    // æ‰§è¡Œå·¥å…·
    const result = await toolRegistry.execute(toolName, parameters)
    
    return NextResponse.json({
      success: true,
      data: result
    })
    
  } catch (error) {
    return NextResponse.json({
      success: false,
      error: error.message
    }, { status: 500 })
  }
}

// æ‰¹é‡å·¥å…·æ‰§è¡Œ
export async function POST(request: NextRequest) {
  const { toolCalls } = await request.json()
  const results = []
  
  for (const toolCall of toolCalls) {
    try {
      const result = await toolRegistry.execute(
        toolCall.tool, 
        toolCall.parameters
      )
      results.push({ success: true, result })
    } catch (error) {
      results.push({ success: false, error: error.message })
    }
  }
  
  return NextResponse.json({ results })
}
\`\`\`

## ğŸ’¾ æ•°æ®å±‚æ¶æ„

### æ•°æ®åº“è®¾è®¡ (PostgreSQL + Prisma)

\`\`\`prisma
// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  goals     Goal[]
  projects  Project[]
  tasks     Task[]
  reviews   Review[]
}

model Goal {
  id          String    @id @default(cuid())
  title       String
  description String?
  stage       GoalStage
  deadline    DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  userId      String
  user        User      @relation(fields: [userId], references: [id])
  projects    Project[] @relation("GoalProjects")
}

model Project {
  id          String        @id @default(cuid())
  name        String
  description String?
  status      ProjectStatus @default(ACTIVE)
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  
  userId      String
  user        User          @relation(fields: [userId], references: [id])
  goals       Goal[]        @relation("GoalProjects")
  tasks       Task[]
  reviews     Review[]      @relation("ProjectReviews")
}

model Task {
  id          String    @id @default(cuid())
  title       String
  description String?
  completed   Boolean   @default(false)
  priority    Priority  @default(MEDIUM)
  dueDate     DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  
  userId      String
  user        User      @relation(fields: [userId], references: [id])
  projectId   String?
  project     Project?  @relation(fields: [projectId], references: [id])
}

model Review {
  id        String     @id @default(cuid())
  content   String
  type      ReviewType
  tags      String[]
  mood      Int?       @default(5)
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  
  userId    String
  user      User       @relation(fields: [userId], references: [id])
  projects  Project[]  @relation("ProjectReviews")
}

enum GoalStage {
  LIFE
  YEARLY
  QUARTER
}

enum ProjectStatus {
  ACTIVE
  PAUSED
  COMPLETED
}

enum Priority {
  LOW
  MEDIUM
  HIGH
}

enum ReviewType {
  DAILY
  WEEKLY
  MONTHLY
}
\`\`\`

### æ•°æ®è®¿é—®å±‚

\`\`\`typescript
// lib/db/client.ts
import { PrismaClient } from '@prisma/client'

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined
}

export const prisma = globalForPrisma.prisma ?? new PrismaClient()

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma

// lib/db/repositories/project-repository.ts
export class ProjectRepository {
  async create(data: CreateProjectData): Promise<Project> {
    return prisma.project.create({
      data,
      include: {
        goals: true,
        tasks: true,
        reviews: true
      }
    })
  }
  
  async findById(id: string): Promise<Project | null> {
    return prisma.project.findUnique({
      where: { id },
      include: {
        goals: true,
        tasks: true,
        reviews: true
      }
    })
  }
  
  async update(id: string, data: UpdateProjectData): Promise<Project> {
    return prisma.project.update({
      where: { id },
      data,
      include: {
        goals: true,
        tasks: true,
        reviews: true
      }
    })
  }
  
  async delete(id: string): Promise<void> {
    await prisma.project.delete({
      where: { id }
    })
  }
  
  async findByUserId(userId: string): Promise<Project[]> {
    return prisma.project.findMany({
      where: { userId },
      include: {
        goals: true,
        tasks: true,
        reviews: true
      },
      orderBy: { updatedAt: 'desc' }
    })
  }
}
\`\`\`

### æ•°æ®åŒæ­¥ç­–ç•¥

\`\`\`typescript
// lib/sync/data-sync.ts
export class DataSyncManager {
  private repositories: Map<string, any> = new Map()
  
  constructor() {
    this.repositories.set('project', new ProjectRepository())
    this.repositories.set('goal', new GoalRepository())
    this.repositories.set('task', new TaskRepository())
    this.repositories.set('review', new ReviewRepository())
  }
  
  async syncToDatabase(toolName: string, result: any): Promise<void> {
    const entityType = this.getEntityType(toolName)
    const repository = this.repositories.get(entityType)
    
    if (!repository) return
    
    switch (toolName) {
      case 'createProject':
        await repository.create(result)
        break
      case 'updateProject':
        await repository.update(result.id, result)
        break
      case 'deleteProject':
        await repository.delete(result.id)
        break
      // ... å…¶ä»–å·¥å…·åŒæ­¥é€»è¾‘
    }
  }
  
  async syncFromDatabase(userId: string): Promise<void> {
    const store = useLifeAgentStore.getState()
    
    // åŒæ­¥æ‰€æœ‰æ•°æ®
    const [projects, goals, tasks, reviews] = await Promise.all([
      this.repositories.get('project').findByUserId(userId),
      this.repositories.get('goal').findByUserId(userId),
      this.repositories.get('task').findByUserId(userId),
      this.repositories.get('review').findByUserId(userId)
    ])
    
    // æ›´æ–°æœ¬åœ°çŠ¶æ€
    store.setProjects(projects)
    store.setGoals(goals)
    store.setTasks(tasks)
    store.setReviews(reviews)
  }
  
  private getEntityType(toolName: string): string {
    if (toolName.includes('Project')) return 'project'
    if (toolName.includes('Goal')) return 'goal'
    if (toolName.includes('Task')) return 'task'
    if (toolName.includes('Review')) return 'review'
    return 'unknown'
  }
}
\`\`\`

## ğŸ”Œ å¤–éƒ¨ï¿½ï¿½ï¿½æˆ

### AI SDK é›†æˆ

\`\`\`typescript
// lib/ai/openai-integration.ts
import { openai } from '@ai-sdk/openai'
import { generateText, tool } from 'ai'
import { z } from 'zod'

export class AIEnhancedIntentParser {
  async parseIntentWithLLM(message: string): Promise<ParsedIntent> {
    const { text } = await generateText({
      model: openai('gpt-4'),
      prompt: `
        åˆ†æç”¨æˆ·æ¶ˆæ¯çš„æ„å›¾ï¼Œå¹¶æå–ç›¸å…³å®ä½“ã€‚
        
        ç”¨æˆ·æ¶ˆæ¯: "${message}"
        
        å¯èƒ½çš„æ„å›¾ç±»å‹:
        - create_project: åˆ›å»ºé¡¹ç›®
        - update_project: æ›´æ–°é¡¹ç›®
        - create_task: åˆ›å»ºä»»åŠ¡
        - write_review: å†™åæ€
        - get_status: è·å–çŠ¶æ€
        
        è¯·è¿”å› JSON æ ¼å¼çš„ç»“æœã€‚
      `,
      tools: {
        analyzeIntent: tool({
          description: 'åˆ†æç”¨æˆ·æ„å›¾',
          parameters: z.object({
            action: z.enum(['create_project', 'update_project', 'create_task', 'write_review', 'get_status']),
            entities: z.object({
              projectName: z.string().optional(),
              taskTitle: z.string().optional(),
              status: z.enum(['active', 'paused', 'completed']).optional(),
              content: z.string().optional()
            }),
            confidence: z.number().min(0).max(1)
          }),
          execute: async (params) => params
        })
      }
    })
    
    return JSON.parse(text)
  }
}

// Function Calling å·¥å…·å®šä¹‰
export const FUNCTION_CALLING_TOOLS = [
  {
    name: 'createProject',
    description: 'åˆ›å»ºæ–°é¡¹ç›®',
    parameters: {
      type: 'object',
      properties: {
        name: { type: 'string', description: 'é¡¹ç›®åç§°' },
        description: { type: 'string', description: 'é¡¹ç›®æè¿°' },
        goalIds: { 
          type: 'array', 
          items: { type: 'string' },
          description: 'å…³è”çš„ç›®æ ‡IDåˆ—è¡¨'
        }
      },
      required: ['name']
    }
  },
  {
    name: 'updateProject',
    description: 'æ›´æ–°é¡¹ç›®ä¿¡æ¯',
    parameters: {
      type: 'object',
      properties: {
        projectId: { type: 'string', description: 'é¡¹ç›®ID' },
        updates: {
          type: 'object',
          properties: {
            name: { type: 'string' },
            status: { type: 'string', enum: ['active', 'paused', 'completed'] }
          }
        }
      },
      required: ['projectId', 'updates']
    }
  }
  // ... æ›´å¤šå·¥å…·å®šä¹‰
]
\`\`\`

## ğŸš€ éƒ¨ç½²æ¶æ„

### Vercel éƒ¨ç½²é…ç½®

\`\`\`json
// vercel.json
{
  "framework": "nextjs",
  "buildCommand": "npm run build",
  "devCommand": "npm run dev",
  "installCommand": "npm install",
  "functions": {
    "app/api/chat/route.ts": {
      "maxDuration": 30
    },
    "app/api/tools/route.ts": {
      "maxDuration": 15
    }
  },
  "env": {
    "DATABASE_URL": "@database-url",
    "OPENAI_API_KEY": "@openai-api-key",
    "NEXTAUTH_SECRET": "@nextauth-secret"
  }
}
\`\`\`

### ç¯å¢ƒé…ç½®

\`\`\`bash
# .env.local
DATABASE_URL="postgresql://username:password@localhost:5432/lifeagent"
OPENAI_API_KEY="sk-..."
NEXTAUTH_URL="http://localhost:3000"
NEXTAUTH_SECRET="your-secret-key"

# Production
DATABASE_URL="postgresql://prod-user:prod-pass@prod-host:5432/lifeagent_prod"
REDIS_URL="redis://localhost:6379"
\`\`\`

### Docker é…ç½®

\`\`\`dockerfile
# Dockerfile
FROM node:18-alpine AS base

# Install dependencies only when needed
FROM base AS deps
RUN apk add --no-cache libc6-compat
WORKDIR /app

COPY package.json package-lock.json* ./
RUN npm ci

# Rebuild the source code only when needed
FROM base AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .

# Generate Prisma client
RUN npx prisma generate

# Build the application
RUN npm run build

# Production image, copy all the files and run next
FROM base AS runner
WORKDIR /app

ENV NODE_ENV production

RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs

COPY --from=builder /app/public ./public
COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./
COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static

USER nextjs

EXPOSE 3000

ENV PORT 3000
ENV HOSTNAME "0.0.0.0"

CMD ["node", "server.js"]
\`\`\`

### ç›‘æ§å’Œæ—¥å¿—

\`\`\`typescript
// lib/monitoring/logger.ts
import { createLogger, format, transports } from 'winston'

export const logger = createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: format.combine(
    format.timestamp(),
    format.errors({ stack: true }),
    format.json()
  ),
  defaultMeta: { service: 'lifeagent' },
  transports: [
    new transports.File({ filename: 'logs/error.log', level: 'error' }),
    new transports.File({ filename: 'logs/combined.log' }),
    new transports.Console({
      format: format.combine(
        format.colorize(),
        format.simple()
      )
    })
  ]
})

// lib/monitoring/metrics.ts
export class MetricsCollector {
  private static instance: MetricsCollector
  private metrics: Map<string, number> = new Map()
  
  static getInstance(): MetricsCollector {
    if (!MetricsCollector.instance) {
      MetricsCollector.instance = new MetricsCollector()
    }
    return MetricsCollector.instance
  }
  
  incrementCounter(name: string): void {
    const current = this.metrics.get(name) || 0
    this.metrics.set(name, current + 1)
  }
  
  recordDuration(name: string, duration: number): void {
    this.metrics.set(`${name}_duration`, duration)
  }
  
  getMetrics(): Record<string, number> {
    return Object.fromEntries(this.metrics)
  }
}

// åœ¨ ChatAgent ä¸­ä½¿ç”¨
export class ChatAgent {
  async processMessage(message: string): Promise<AgentResponse> {
    const startTime = Date.now()
    const metrics = MetricsCollector.getInstance()
    
    try {
      metrics.incrementCounter('chat_messages_processed')
      
      const result = await this.doProcessMessage(message)
      
      metrics.incrementCounter('chat_messages_success')
      return result
      
    } catch (error) {
      metrics.incrementCounter('chat_messages_error')
      logger.error('ChatAgent processing failed', { message, error })
      throw error
      
    } finally {
      const duration = Date.now() - startTime
      metrics.recordDuration('chat_processing', duration)
    }
  }
}
\`\`\`

## ğŸ”’ å®‰å…¨å’Œè®¤è¯

### NextAuth.js é›†æˆ

\`\`\`typescript
// lib/auth/config.ts
import { NextAuthOptions } from 'next-auth'
import { PrismaAdapter } from '@next-auth/prisma-adapter'
import GoogleProvider from 'next-auth/providers/google'
import { prisma } from '@/lib/db/client'

export const authOptions: NextAuthOptions = {
  adapter: PrismaAdapter(prisma),
  providers: [
    GoogleProvider({
      clientId: process.env.GOOGLE_CLIENT_ID!,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET!,
    }),
  ],
  callbacks: {
    session: async ({ session, token }) => {
      if (session?.user) {
        session.user.id = token.sub!
      }
      return session
    },
    jwt: async ({ user, token }) => {
      if (user) {
        token.uid = user.id
      }
      return token
    },
  },
  session: {
    strategy: 'jwt',
  },
}

// middleware.ts
import { withAuth } from 'next-auth/middleware'

export default withAuth(
  function middleware(req) {
    // ä¸­é—´ä»¶é€»è¾‘
  },
  {
    callbacks: {
      authorized: ({ token }) => !!token,
    },
  }
)

export const config = {
  matcher: ['/api/chat/:path*', '/api/tools/:path*', '/dashboard/:path*']
}
\`\`\`

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–

### ç¼“å­˜ç­–ç•¥

\`\`\`typescript
// lib/cache/redis-cache.ts
import Redis from 'ioredis'

export class CacheManager {
  private redis: Redis
  
  constructor() {
    this.redis = new Redis(process.env.REDIS_URL!)
  }
  
  async get<T>(key: string): Promise<T | null> {
    const value = await this.redis.get(key)
    return value ? JSON.parse(value) : null
  }
  
  async set(key: string, value: any, ttl: number = 3600): Promise<void> {
    await this.redis.setex(key, ttl, JSON.stringify(value))
  }
  
  async invalidate(pattern: string): Promise<void> {
    const keys = await this.redis.keys(pattern)
    if (keys.length > 0) {
      await this.redis.del(...keys)
    }
  }
}

// åœ¨ API è·¯ç”±ä¸­ä½¿ç”¨ç¼“å­˜
export async function GET(request: NextRequest) {
  const cache = new CacheManager()
  const userId = await getUserId(request)
  const cacheKey = `projects:${userId}`
  
  // å°è¯•ä»ç¼“å­˜è·å–
  let projects = await cache.get(cacheKey)
  
  if (!projects) {
    // ä»æ•°æ®åº“è·å–
    projects = await projectRepository.findByUserId(userId)
    
    // ç¼“å­˜ç»“æœ
    await cache.set(cacheKey, projects, 1800) // 30åˆ†é’Ÿ
  }
  
  return NextResponse.json({ projects })
}
\`\`\`

### æ•°æ®åº“ä¼˜åŒ–

\`\`\`sql
-- æ•°æ®åº“ç´¢å¼•ä¼˜åŒ–
CREATE INDEX idx_projects_user_id ON projects(user_id);
CREATE INDEX idx_projects_status ON projects(status);
CREATE INDEX idx_tasks_project_id ON tasks(project_id);
CREATE INDEX idx_tasks_due_date ON tasks(due_date);
CREATE INDEX idx_reviews_user_id_created_at ON reviews(user_id, created_at);

-- å¤åˆç´¢å¼•
CREATE INDEX idx_projects_user_status ON projects(user_id, status);
CREATE INDEX idx_tasks_user_completed ON tasks(user_id, completed);
\`\`\`

è¿™ä¸ªå®Œæ•´çš„å‰åç«¯æ¶æ„è®¾è®¡ä¸º LifeAgent æä¾›äº†ï¼š

1. **å¯æ‰©å±•çš„å‰ç«¯æ¶æ„** - æ¨¡å—åŒ–ç»„ä»¶ã€çŠ¶æ€ç®¡ç†ã€å®æ—¶æ›´æ–°
2. **å¼ºå¤§çš„ API å±‚** - RESTful è®¾è®¡ã€å·¥å…·æ‰§è¡Œã€æµå¼å“åº”
3. **å¯é çš„æ•°æ®å±‚** - PostgreSQL + Prismaã€æ•°æ®åŒæ­¥ã€ç¼“å­˜ç­–ç•¥
4. **AI é›†æˆèƒ½åŠ›** - OpenAI APIã€Function Callingã€æ„å›¾å¢å¼º
5. **ç”Ÿäº§çº§éƒ¨ç½²** - Dockerã€Vercelã€ç›‘æ§ã€å®‰å…¨è®¤è¯

æ•´ä¸ªæ¶æ„æ—¢æ”¯æŒå½“å‰çš„ MVP åŠŸèƒ½ï¼Œä¹Ÿä¸ºæœªæ¥çš„æ‰©å±•ï¼ˆå¦‚ CodingAgentã€å‘é‡æ•°æ®åº“ã€æ›´å¤æ‚çš„ AI åŠŸèƒ½ï¼‰é¢„ç•™äº†å……è¶³çš„ç©ºé—´ã€‚
